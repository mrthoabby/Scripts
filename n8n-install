#!/bin/bash

###############################################################################
#
#  INSTALACIÃ“N PROFESIONAL DE N8N EN GCP - PRODUCCIÃ“N
#  
#  Requisitos:
#  - MÃ¡quina: 4 vCPUs, 8 GB RAM, 60 GB SSD
#  - SO: Debian 12 / Ubuntu 22.04
#  - Nginx ya instalado en el host
#  - Dominio: n8n.gedabengineers.dev apuntando a la IP del servidor
#
###############################################################################

set -e

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
NC='\033[0m'

# Variables
INSTALL_DIR="/opt/n8n-production"
LOG_FILE="/var/log/n8n-install.log"
DOMAIN="n8n.gedabengineers.dev"
N8N_PORT="5678"

# FunciÃ³n de logging
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

print_banner() {
    clear
    echo -e "${CYAN}"
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                      â•‘
â•‘     ğŸš€ INSTALACIÃ“N N8N PROFESIONAL - PRODUCCIÃ“N GCP ğŸš€              â•‘
â•‘                                                                      â•‘
â•‘     Dominio: n8n.gedabengineers.dev                                 â•‘
â•‘     Servidor: 4 vCPUs | 8 GB RAM | 60 GB SSD                        â•‘
â•‘                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${NC}"
}

print_success() {
    echo -e "${GREEN}  âœ“${NC} $1"
    log "SUCCESS: $1"
}

print_error() {
    echo -e "${RED}  âœ—${NC} $1"
    log "ERROR: $1"
}

print_info() {
    echo -e "${BLUE}  â„¹${NC} $1"
    log "INFO: $1"
}

print_warning() {
    echo -e "${YELLOW}  âš ${NC} $1"
    log "WARNING: $1"
}

print_header() {
    echo ""
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}â•‘${NC}  ${WHITE}$1${NC}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

# Verificar que se ejecuta como root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        print_error "Este script debe ejecutarse como root"
        echo "Ejecuta: sudo bash $0"
        exit 1
    fi
}

# Verificar requisitos del sistema
check_system_requirements() {
    print_header "VERIFICACIÃ“N DE REQUISITOS DEL SISTEMA"
    
    local all_ok=true
    
    # Verificar CPU
    local cpus=$(nproc)
    print_info "CPUs detectadas: $cpus"
    if [ "$cpus" -lt 4 ]; then
        print_error "Se requieren al menos 4 vCPUs (tienes $cpus)"
        all_ok=false
    else
        print_success "CPUs: OK ($cpus vCPUs)"
    fi
    
    # Verificar RAM
    local ram_gb=$(free -g | awk '/^Mem:/{print $2}')
    print_info "RAM detectada: ${ram_gb} GB"
    if [ "$ram_gb" -lt 7 ]; then
        print_error "Se requieren al menos 8 GB de RAM (tienes ${ram_gb} GB)"
        all_ok=false
    else
        print_success "RAM: OK (${ram_gb} GB)"
    fi
    
    # Verificar disco
    local disk_gb=$(df -BG / | awk 'NR==2 {print $4}' | sed 's/G//')
    print_info "Disco disponible: ${disk_gb} GB"
    if [ "$disk_gb" -lt 40 ]; then
        print_warning "Se recomienda al menos 60 GB disponibles (tienes ${disk_gb} GB)"
    else
        print_success "Disco: OK (${disk_gb} GB disponibles)"
    fi
    
    # Verificar Nginx
    if systemctl is-active --quiet nginx; then
        print_success "Nginx: INSTALADO Y CORRIENDO"
    else
        print_error "Nginx no estÃ¡ corriendo"
        all_ok=false
    fi
    
    # Verificar DNS
    print_info "Verificando DNS para $DOMAIN..."
    local resolved_ip=$(dig +short $DOMAIN @8.8.8.8 | tail -1)
    local server_ip=$(curl -s ifconfig.me)
    
    if [ -n "$resolved_ip" ]; then
        if [[ "$resolved_ip" =~ ^104\.2[0-9]\. ]] || [[ "$resolved_ip" =~ ^172\.6[4-7]\. ]]; then
            print_success "DNS: $DOMAIN â†’ Cloudflare Proxy ($resolved_ip)"
            print_warning "Nota: Usa Cloudflare, verifica que apunte a: $server_ip"
        elif [ "$resolved_ip" == "$server_ip" ]; then
            print_success "DNS: $DOMAIN â†’ $resolved_ip âœ“"
        else
            print_warning "DNS: $DOMAIN â†’ $resolved_ip (IP servidor: $server_ip)"
        fi
    else
        print_error "DNS no resuelve para $DOMAIN"
        all_ok=false
    fi
    
    echo ""
    
    if ! $all_ok; then
        print_error "Algunos requisitos no se cumplen"
        read -p "Â¿Deseas continuar de todas formas? (y/N): " response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
    
    print_success "VerificaciÃ³n de requisitos completada"
}

# Solicitar informaciÃ³n al usuario
collect_user_input() {
    print_header "CONFIGURACIÃ“N DE CREDENCIALES"
    
    echo -e "${YELLOW}Por favor, proporciona las siguientes credenciales:${NC}"
    echo ""
    
    # Email para SSL
    read -p "$(echo -e ${CYAN}Email para certificados SSL:${NC}) " CERTBOT_EMAIL
    while [[ ! "$CERTBOT_EMAIL" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; do
        print_error "Email invÃ¡lido"
        read -p "$(echo -e ${CYAN}Email para certificados SSL:${NC}) " CERTBOT_EMAIL
    done
    
    # PostgreSQL password
    read -sp "$(echo -e ${CYAN}Password para PostgreSQL:${NC}) " POSTGRES_PASSWORD
    echo ""
    while [ ${#POSTGRES_PASSWORD} -lt 12 ]; do
        print_error "La contraseÃ±a debe tener al menos 12 caracteres"
        read -sp "$(echo -e ${CYAN}Password para PostgreSQL:${NC}) " POSTGRES_PASSWORD
        echo ""
    done
    
    # N8N admin user
    read -p "$(echo -e ${CYAN}Usuario admin de n8n \(default: admin\):${NC}) " N8N_ADMIN_USER
    N8N_ADMIN_USER=${N8N_ADMIN_USER:-admin}
    
    # N8N admin password
    read -sp "$(echo -e ${CYAN}Password para admin de n8n:${NC}) " N8N_ADMIN_PASSWORD
    echo ""
    while [ ${#N8N_ADMIN_PASSWORD} -lt 12 ]; do
        print_error "La contraseÃ±a debe tener al menos 12 caracteres"
        read -sp "$(echo -e ${CYAN}Password para admin de n8n:${NC}) " N8N_ADMIN_PASSWORD
        echo ""
    done
    
    # Generar claves aleatorias
    print_info "Generando claves de encriptaciÃ³n..."
    N8N_ENCRYPTION_KEY=$(openssl rand -base64 32 | tr -d '\n')
    N8N_RUNNERS_TOKEN=$(openssl rand -base64 32 | tr -d '\n')
    
    echo ""
    print_success "Credenciales configuradas"
}

# Instalar Docker si no estÃ¡ instalado
install_docker() {
    print_header "INSTALACIÃ“N DE DOCKER"
    
    if command -v docker &> /dev/null; then
        print_success "Docker ya estÃ¡ instalado: $(docker --version)"
        return 0
    fi
    
    print_info "Instalando Docker..."
    
    # Remover versiones antiguas
    apt-get remove -y docker docker-engine docker.io containerd runc 2>/dev/null || true
    
    # Instalar dependencias
    apt-get update -qq
    apt-get install -y -qq \
        apt-transport-https \
        ca-certificates \
        curl \
        gnupg \
        lsb-release \
        software-properties-common
    
    # Agregar clave GPG de Docker
    install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    chmod a+r /etc/apt/keyrings/docker.gpg
    
    # Agregar repositorio
    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
      $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    # Instalar Docker
    apt-get update -qq
    apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    
    # Habilitar y arrancar Docker
    systemctl enable docker
    systemctl start docker
    
    print_success "Docker instalado: $(docker --version)"
    print_success "Docker Compose instalado: $(docker compose version)"
}

# Crear estructura de directorios
create_directories() {
    print_header "CREACIÃ“N DE ESTRUCTURA DE DIRECTORIOS"
    
    print_info "Creando directorios en $INSTALL_DIR..."
    
    mkdir -p "$INSTALL_DIR"/{backups/{postgres,n8n-data},scripts,logs}
    
    print_success "Estructura de directorios creada"
    
    cd "$INSTALL_DIR"
    print_info "Directorio de trabajo: $(pwd)"
}

# Crear archivo .env
create_env_file() {
    print_header "CREACIÃ“N DE ARCHIVO DE CONFIGURACIÃ“N"
    
    print_info "Generando archivo .env..."
    
    cat > "$INSTALL_DIR/.env" << EOF
###############################################################################
# CONFIGURACIÃ“N N8N PRODUCCIÃ“N
# Generado: $(date)
###############################################################################

# === BASE DE DATOS POSTGRESQL ===
POSTGRES_DB=n8n_production
POSTGRES_USER=n8n_user
POSTGRES_PASSWORD=${POSTGRES_PASSWORD}

# === N8N SEGURIDAD ===
N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
N8N_BASIC_AUTH_USER=${N8N_ADMIN_USER}
N8N_BASIC_AUTH_PASSWORD=${N8N_ADMIN_PASSWORD}
N8N_RUNNERS_AUTH_TOKEN=${N8N_RUNNERS_TOKEN}

# === CONFIGURACIÃ“N DE RED ===
N8N_HOST=${DOMAIN}
N8N_PROTOCOL=https
N8N_PORT=${N8N_PORT}

# === TIMEZONE ===
GENERIC_TIMEZONE=America/Bogota
TZ=America/Bogota

# === SSL ===
CERTBOT_EMAIL=${CERTBOT_EMAIL}

# === VERSIONES ===
N8N_VERSION=latest
POSTGRES_VERSION=15
REDIS_VERSION=7
EOF
    
    chmod 600 "$INSTALL_DIR/.env"
    
    print_success "Archivo .env creado y asegurado"
}

# Crear docker-compose.yml
create_docker_compose() {
    print_header "CREACIÃ“N DE DOCKER COMPOSE"
    
    print_info "Generando docker-compose.yml optimizado..."
    
    cat > "$INSTALL_DIR/docker-compose.yml" << 'EOF'
version: '3.8'

###############################################################################
# N8N PRODUCCIÃ“N - CONFIGURACIÃ“N OPTIMIZADA
# Servidor: 4 vCPUs, 8 GB RAM
# DistribuciÃ³n: 75% contenedores, 25% sistema
###############################################################################

services:
  # === PostgreSQL Database ===
  postgres:
    image: postgres:${POSTGRES_VERSION:-15}-alpine
    container_name: n8n_postgres
    restart: always
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --lc-collate=C --lc-ctype=C"
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - n8n_network
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -h localhost -U ${POSTGRES_USER} -d ${POSTGRES_DB}']
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2560M
        reservations:
          cpus: '0.5'
          memory: 1536M
    shm_size: 256mb
    command: >
      postgres
      -c max_connections=100
      -c shared_buffers=256MB
      -c effective_cache_size=1GB
      -c maintenance_work_mem=128MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=2621kB
      -c min_wal_size=1GB
      -c max_wal_size=4GB
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # === Redis Cache & Queue ===
  redis:
    image: redis:${REDIS_VERSION:-7}-alpine
    container_name: n8n_redis
    restart: always
    command: >
      redis-server
      --appendonly yes
      --appendfsync everysec
      --maxmemory 768mb
      --maxmemory-policy allkeys-lru
      --save 900 1
      --save 300 10
      --save 60 10000
    volumes:
      - redis_data:/data
    networks:
      - n8n_network
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 1024M
        reservations:
          cpus: '0.25'
          memory: 512M
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "3"

  # === N8N Application ===
  n8n:
    image: docker.n8n.io/n8nio/n8n:${N8N_VERSION:-latest}
    container_name: n8n_app
    restart: always
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    ports:
      - "127.0.0.1:${N8N_PORT}:5678"
    environment:
      # === Database ===
      DB_TYPE: postgresdb
      DB_POSTGRESDB_HOST: postgres
      DB_POSTGRESDB_PORT: 5432
      DB_POSTGRESDB_DATABASE: ${POSTGRES_DB}
      DB_POSTGRESDB_USER: ${POSTGRES_USER}
      DB_POSTGRESDB_PASSWORD: ${POSTGRES_PASSWORD}
      DB_POSTGRESDB_SCHEMA: public
      
      # === Security ===
      N8N_ENCRYPTION_KEY: ${N8N_ENCRYPTION_KEY}
      N8N_BASIC_AUTH_ACTIVE: "true"
      N8N_BASIC_AUTH_USER: ${N8N_BASIC_AUTH_USER}
      N8N_BASIC_AUTH_PASSWORD: ${N8N_BASIC_AUTH_PASSWORD}
      
      # === Network ===
      N8N_HOST: ${N8N_HOST}
      N8N_PROTOCOL: ${N8N_PROTOCOL}
      N8N_PORT: 5678
      WEBHOOK_URL: ${N8N_PROTOCOL}://${N8N_HOST}/
      
      # === Queue Mode (Redis) ===
      QUEUE_BULL_REDIS_HOST: redis
      QUEUE_BULL_REDIS_PORT: 6379
      QUEUE_BULL_REDIS_DB: 0
      EXECUTIONS_MODE: queue
      
      # === Runners (Code Isolation) ===
      N8N_RUNNERS_ENABLED: "true"
      N8N_RUNNERS_AUTH_TOKEN: ${N8N_RUNNERS_AUTH_TOKEN}
      N8N_RUNNERS_MODE: internal
      
      # === Timezone ===
      GENERIC_TIMEZONE: ${GENERIC_TIMEZONE}
      TZ: ${TZ}
      
      # === Execution Settings ===
      EXECUTIONS_DATA_PRUNE: "true"
      EXECUTIONS_DATA_MAX_AGE: 720
      EXECUTIONS_DATA_SAVE_ON_ERROR: all
      EXECUTIONS_DATA_SAVE_ON_SUCCESS: all
      EXECUTIONS_DATA_SAVE_MANUAL_EXECUTIONS: "true"
      EXECUTIONS_TIMEOUT: 3600
      EXECUTIONS_TIMEOUT_MAX: 7200
      
      # === Performance ===
      N8N_PAYLOAD_SIZE_MAX: 16
      N8N_METRICS: "true"
      N8N_CONCURRENCY_PRODUCTION_LIMIT: 10
      
      # === Node.js Settings ===
      NODE_ENV: production
      NODE_FUNCTION_ALLOW_BUILTIN: "*"
      NODE_FUNCTION_ALLOW_EXTERNAL: "*"
      NODE_OPTIONS: "--max-old-space-size=3072"
      
      # === Logging ===
      N8N_LOG_LEVEL: info
      N8N_LOG_OUTPUT: console,file
      N8N_LOG_FILE_LOCATION: /home/node/.n8n/logs/
      N8N_LOG_FILE_MAX_SIZE: 10m
      N8N_LOG_FILE_MAX_COUNT: 10
      
      # === User Management ===
      N8N_USER_MANAGEMENT_DISABLED: "false"
      N8N_PUBLIC_API_DISABLED: "false"
      
      # === Misc ===
      N8N_DIAGNOSTICS_ENABLED: "true"
      N8N_VERSION_NOTIFICATIONS_ENABLED: "true"
      N8N_TEMPLATES_ENABLED: "true"
      N8N_HIRING_BANNER_ENABLED: "false"
      N8N_PERSONALIZATION_ENABLED: "true"
    volumes:
      - n8n_data:/home/node/.n8n
      - n8n_files:/files
    networks:
      - n8n_network
    healthcheck:
      test: ['CMD-SHELL', 'wget --spider -q http://localhost:5678/healthz || exit 1']
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    deploy:
      resources:
        limits:
          cpus: '2.5'
          memory: 4096M
        reservations:
          cpus: '1.5'
          memory: 2560M
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-/opt/n8n-production}/data/postgres
  
  redis_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-/opt/n8n-production}/data/redis
  
  n8n_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-/opt/n8n-production}/data/n8n
  
  n8n_files:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-/opt/n8n-production}/data/files

networks:
  n8n_network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16
EOF
    
    # Crear directorios para volÃºmenes
    mkdir -p "$INSTALL_DIR/data"/{postgres,redis,n8n,files}
    
    print_success "Docker Compose creado con optimizaciones"
}

# Configurar Nginx
configure_nginx() {
    print_header "CONFIGURACIÃ“N DE NGINX"
    
    print_info "Creando configuraciÃ³n para $DOMAIN..."
    
    # Backup de configuraciÃ³n existente si existe
    if [ -f "/etc/nginx/sites-available/$DOMAIN" ]; then
        print_warning "Ya existe una configuraciÃ³n para $DOMAIN"
        cp "/etc/nginx/sites-available/$DOMAIN" "/etc/nginx/sites-available/${DOMAIN}.backup.$(date +%Y%m%d_%H%M%S)"
        print_info "Backup creado"
    fi
    
    # Crear configuraciÃ³n de Nginx
    cat > "/etc/nginx/sites-available/$DOMAIN" << EOF
##############################################################################
# N8N - n8n.gedabengineers.dev
# Generado: $(date)
##############################################################################

# LÃ­mites de rate (protecciÃ³n DDoS bÃ¡sica)
limit_req_zone \$binary_remote_addr zone=n8n_limit:10m rate=10r/s;
limit_conn_zone \$binary_remote_addr zone=n8n_conn:10m;

# Upstream para n8n
upstream n8n_backend {
    server 127.0.0.1:${N8N_PORT} fail_timeout=30s max_fails=3;
    keepalive 32;
}

# RedirecciÃ³n HTTP â†’ HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name ${DOMAIN};

    # ACME Challenge para Let's Encrypt
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
        try_files \$uri =404;
    }

    # RedirecciÃ³n a HTTPS
    location / {
        return 301 https://\$server_name\$request_uri;
    }
}

# Servidor HTTPS
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${DOMAIN};

    # === Certificados SSL ===
    ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
    ssl_trusted_certificate /etc/letsencrypt/live/${DOMAIN}/chain.pem;

    # === ConfiguraciÃ³n SSL Moderna (Mozilla Intermediate) ===
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers off;
    
    # SSL Session
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;
    ssl_session_tickets off;
    
    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;

    # === Security Headers ===
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;

    # === Logs ===
    access_log /var/log/nginx/n8n_access.log combined buffer=32k flush=5s;
    error_log /var/log/nginx/n8n_error.log warn;

    # === TamaÃ±os y Timeouts ===
    client_max_body_size 50M;
    client_body_buffer_size 128k;
    client_body_timeout 60s;
    client_header_timeout 60s;
    send_timeout 300s;

    # === Proxy a n8n ===
    location / {
        # Rate limiting
        limit_req zone=n8n_limit burst=20 nodelay;
        limit_conn n8n_conn 10;
        
        # Proxy pass
        proxy_pass http://n8n_backend;
        proxy_http_version 1.1;
        
        # Headers bÃ¡sicos
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_set_header X-Forwarded-Port \$server_port;
        
        # WebSocket support (crucial para n8n)
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 300s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        
        # Buffering
        proxy_buffering off;
        proxy_request_buffering off;
        proxy_cache_bypass \$http_upgrade;
        
        # Redirect handling
        proxy_redirect off;
    }

    # Health check endpoint (sin rate limit)
    location /healthz {
        proxy_pass http://n8n_backend/healthz;
        access_log off;
    }

    # Bloquear acceso a archivos sensibles
    location ~ /\\.(?!well-known).* {
        deny all;
        access_log off;
        log_not_found off;
    }
}
EOF
    
    # Habilitar sitio
    ln -sf "/etc/nginx/sites-available/$DOMAIN" "/etc/nginx/sites-enabled/$DOMAIN"
    
    print_success "ConfiguraciÃ³n de Nginx creada"
    
    # Verificar configuraciÃ³n
    print_info "Verificando configuraciÃ³n de Nginx..."
    if nginx -t 2>&1 | grep -q "syntax is ok"; then
        print_success "ConfiguraciÃ³n de Nginx: OK"
    else
        print_error "Error en configuraciÃ³n de Nginx"
        nginx -t
        return 1
    fi
}

# Generar certificado SSL
generate_ssl_certificate() {
    print_header "GENERACIÃ“N DE CERTIFICADO SSL"
    
    # Verificar si certbot estÃ¡ instalado
    if ! command -v certbot &> /dev/null; then
        print_info "Instalando Certbot..."
        apt-get update -qq
        apt-get install -y -qq certbot python3-certbot-nginx
    fi
    
    # Crear directorio para ACME challenge
    mkdir -p /var/www/certbot
    
    # Verificar si ya existe certificado
    if [ -d "/etc/letsencrypt/live/$DOMAIN" ]; then
        print_warning "Ya existe un certificado para $DOMAIN"
        read -p "Â¿Deseas renovarlo/regenerarlo? (y/N): " response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            print_info "Usando certificado existente"
            return 0
        fi
    fi
    
    print_info "Generando certificado SSL para $DOMAIN..."
    print_warning "AsegÃºrate de que el dominio apunte a este servidor"
    
    # Recargar Nginx para que tome la configuraciÃ³n HTTP
    systemctl reload nginx
    
    # Generar certificado
    certbot certonly \
        --nginx \
        --non-interactive \
        --agree-tos \
        --email "$CERTBOT_EMAIL" \
        --domains "$DOMAIN" \
        --rsa-key-size 4096 \
        --must-staple
    
    if [ $? -eq 0 ]; then
        print_success "Certificado SSL generado exitosamente"
        
        # Configurar renovaciÃ³n automÃ¡tica
        print_info "Configurando renovaciÃ³n automÃ¡tica..."
        
        # Verificar si existe el timer de certbot
        if systemctl list-unit-files 2>/dev/null | grep -q "certbot.timer"; then
            systemctl enable certbot.timer
            systemctl start certbot.timer
            print_success "RenovaciÃ³n automÃ¡tica configurada (systemd timer)"
        else
            # Configurar cron como fallback
            (crontab -l 2>/dev/null | grep -v "certbot renew"; echo "0 3,15 * * * /usr/bin/certbot renew --quiet --post-hook 'systemctl reload nginx' >> /var/log/certbot-renewal.log 2>&1") | crontab -
            print_success "RenovaciÃ³n automÃ¡tica configurada (cron)"
        fi
    else
        print_error "Error al generar certificado SSL"
        print_info "Puedes intentar manualmente: certbot certonly --nginx -d $DOMAIN"
        return 1
    fi
}

# Iniciar servicios Docker
start_docker_services() {
    print_header "INICIO DE SERVICIOS DOCKER"
    
    cd "$INSTALL_DIR"
    
    print_info "Descargando imÃ¡genes Docker..."
    docker compose pull
    
    print_info "Iniciando contenedores..."
    docker compose up -d
    
    print_info "Esperando que los servicios estÃ©n listos..."
    sleep 10
    
    # Verificar estado de contenedores
    print_info "Estado de contenedores:"
    docker compose ps
    
    # Verificar health checks
    print_info "Verificando health checks..."
    local retries=0
    local max_retries=30
    
    while [ $retries -lt $max_retries ]; do
        local healthy=$(docker compose ps --format json | jq -r '.Health' | grep -c "healthy")
        local total=$(docker compose ps --format json | wc -l)
        
        if [ "$healthy" -eq "$total" ]; then
            print_success "Todos los contenedores estÃ¡n saludables"
            break
        fi
        
        retries=$((retries + 1))
        print_info "Esperando contenedores saludables... ($retries/$max_retries)"
        sleep 10
    done
    
    if [ $retries -eq $max_retries ]; then
        print_warning "Algunos contenedores tardaron en estar listos"
        docker compose logs --tail=50
    fi
}

# Recargar Nginx
reload_nginx() {
    print_header "RECARGA DE NGINX"
    
    print_info "Verificando configuraciÃ³n de Nginx..."
    if nginx -t; then
        print_info "Recargando Nginx..."
        systemctl reload nginx
        print_success "Nginx recargado correctamente"
    else
        print_error "Error en configuraciÃ³n de Nginx"
        return 1
    fi
}

# Crear scripts de mantenimiento
create_maintenance_scripts() {
    print_header "CREACIÃ“N DE SCRIPTS DE MANTENIMIENTO"
    
    # Script de backup
    cat > "$INSTALL_DIR/scripts/backup.sh" << 'EOF'
#!/bin/bash
# Backup de n8n

BACKUP_DIR="/opt/n8n-production/backups"
DATE=$(date +%Y%m%d_%H%M%S)

echo "=== Backup n8n - $DATE ==="

# Backup PostgreSQL
echo "Respaldando base de datos..."
docker exec n8n_postgres pg_dump -U n8n_user n8n_production | gzip > "$BACKUP_DIR/postgres/n8n_db_$DATE.sql.gz"

# Backup datos de n8n
echo "Respaldando datos de n8n..."
tar -czf "$BACKUP_DIR/n8n-data/n8n_data_$DATE.tar.gz" -C /opt/n8n-production/data/n8n .

# Backup .env
echo "Respaldando configuraciÃ³n..."
cp /opt/n8n-production/.env "$BACKUP_DIR/env_$DATE.backup"

# Limpiar backups antiguos (mantener Ãºltimos 7 dÃ­as)
find "$BACKUP_DIR/postgres" -name "*.sql.gz" -mtime +7 -delete
find "$BACKUP_DIR/n8n-data" -name "*.tar.gz" -mtime +7 -delete

echo "âœ“ Backup completado: $DATE"
EOF
    
    chmod +x "$INSTALL_DIR/scripts/backup.sh"
    
    # Script de restore
    cat > "$INSTALL_DIR/scripts/restore.sh" << 'EOF'
#!/bin/bash
# Restaurar backup de n8n

if [ -z "$1" ]; then
    echo "Uso: $0 <fecha_backup>"
    echo "Ejemplo: $0 20250127_143000"
    exit 1
fi

BACKUP_DIR="/opt/n8n-production/backups"
DATE=$1

echo "=== Restaurando backup de $DATE ==="

# Detener servicios
echo "Deteniendo servicios..."
cd /opt/n8n-production
docker compose down

# Restaurar PostgreSQL
echo "Restaurando base de datos..."
gunzip < "$BACKUP_DIR/postgres/n8n_db_${DATE}.sql.gz" | docker exec -i n8n_postgres psql -U n8n_user n8n_production

# Restaurar datos de n8n
echo "Restaurando datos de n8n..."
rm -rf /opt/n8n-production/data/n8n/*
tar -xzf "$BACKUP_DIR/n8n-data/n8n_data_${DATE}.tar.gz" -C /opt/n8n-production/data/n8n

# Iniciar servicios
echo "Iniciando servicios..."
docker compose up -d

echo "âœ“ RestauraciÃ³n completada"
EOF
    
    chmod +x "$INSTALL_DIR/scripts/restore.sh"
    
    # Configurar backup automÃ¡tico diario
    (crontab -l 2>/dev/null | grep -v "n8n backup"; echo "0 2 * * * $INSTALL_DIR/scripts/backup.sh >> /var/log/n8n-backup.log 2>&1") | crontab -
    
    print_success "Scripts de mantenimiento creados"
    print_info "Backup automÃ¡tico configurado: Diario a las 2:00 AM"
}

# Verificar instalaciÃ³n
verify_installation() {
    print_header "VERIFICACIÃ“N DE INSTALACIÃ“N"
    
    echo ""
    print_info "Verificando servicios..."
    
    # Verificar Docker
    if docker compose ps | grep -q "Up"; then
        print_success "Contenedores Docker: CORRIENDO"
    else
        print_error "Contenedores Docker: PROBLEMA"
    fi
    
    # Verificar Nginx
    if systemctl is-active --quiet nginx; then
        print_success "Nginx: CORRIENDO"
    else
        print_error "Nginx: DETENIDO"
    fi
    
    # Verificar conectividad local
    local http_code=$(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:${N8N_PORT}/healthz" 2>/dev/null || echo "000")
    if [ "$http_code" == "200" ]; then
        print_success "n8n responde localmente: OK"
    else
        print_warning "n8n responde con cÃ³digo: $http_code"
    fi
    
    # Verificar HTTPS
    print_info "Probando conectividad HTTPS..."
    sleep 5
    local https_code=$(curl -s -o /dev/null -w "%{http_code}" "https://${DOMAIN}" 2>/dev/null || echo "000")
    if [ "$https_code" == "200" ] || [ "$https_code" == "401" ]; then
        print_success "HTTPS: OK (cÃ³digo $https_code)"
    else
        print_warning "HTTPS responde con cÃ³digo: $https_code"
    fi
    
    echo ""
}

# Mostrar informaciÃ³n final
show_final_info() {
    print_header "INSTALACIÃ“N COMPLETADA"
    
    echo ""
    echo -e "${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${GREEN}â•‘                                                                      â•‘${NC}"
    echo -e "${GREEN}â•‘  âœ… N8N INSTALADO Y CONFIGURADO EXITOSAMENTE                         â•‘${NC}"
    echo -e "${GREEN}â•‘                                                                      â•‘${NC}"
    echo -e "${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    echo -e "${CYAN}â•â•â• INFORMACIÃ“N DE ACCESO â•â•â•${NC}"
    echo ""
    echo -e "  ${WHITE}ğŸŒ URL:${NC}          https://${DOMAIN}"
    echo -e "  ${WHITE}ğŸ‘¤ Usuario:${NC}      ${N8N_ADMIN_USER}"
    echo -e "  ${WHITE}ğŸ”‘ Password:${NC}     ${N8N_ADMIN_PASSWORD}"
    echo ""
    
    echo -e "${CYAN}â•â•â• RECURSOS DEL SERVIDOR â•â•â•${NC}"
    echo ""
    echo -e "  ${WHITE}Servidor:${NC}        $(nproc) vCPUs | $(free -h | awk '/^Mem:/{print $2}') RAM"
    echo -e "  ${WHITE}Disco:${NC}           $(df -h / | awk 'NR==2 {print $4}') disponibles"
    echo ""
    
    echo -e "${CYAN}â•â•â• DISTRIBUCIÃ“N DE RECURSOS â•â•â•${NC}"
    echo ""
    echo -e "  ${BLUE}n8n:${NC}             2.5 vCPUs (lÃ­mite) | 4 GB RAM (lÃ­mite)"
    echo -e "  ${BLUE}PostgreSQL:${NC}      1.0 vCPUs (lÃ­mite) | 2.5 GB RAM (lÃ­mite)"
    echo -e "  ${BLUE}Redis:${NC}           0.5 vCPUs (lÃ­mite) | 1 GB RAM (lÃ­mite)"
    echo ""
    
    echo -e "${CYAN}â•â•â• COMANDOS ÃšTILES â•â•â•${NC}"
    echo ""
    echo -e "  ${YELLOW}# Ver logs de n8n${NC}"
    echo -e "  docker logs -f n8n_app"
    echo ""
    echo -e "  ${YELLOW}# Ver estado de contenedores${NC}"
    echo -e "  docker compose ps"
    echo -e "  docker stats"
    echo ""
    echo -e "  ${YELLOW}# Reiniciar n8n${NC}"
    echo -e "  docker compose restart n8n"
    echo ""
    echo -e "  ${YELLOW}# Detener todos los servicios${NC}"
    echo -e "  docker compose down"
    echo ""
    echo -e "  ${YELLOW}# Iniciar todos los servicios${NC}"
    echo -e "  docker compose up -d"
    echo ""
    echo -e "  ${YELLOW}# Hacer backup${NC}"
    echo -e "  /opt/n8n-production/scripts/backup.sh"
    echo ""
    echo -e "  ${YELLOW}# Restaurar backup${NC}"
    echo -e "  /opt/n8n-production/scripts/restore.sh <fecha>"
    echo ""
    
    echo -e "${CYAN}â•â•â• ARCHIVOS IMPORTANTES â•â•â•${NC}"
    echo ""
    echo -e "  ${WHITE}InstalaciÃ³n:${NC}     /opt/n8n-production/"
    echo -e "  ${WHITE}ConfiguraciÃ³n:${NC}   /opt/n8n-production/.env"
    echo -e "  ${WHITE}Datos:${NC}           /opt/n8n-production/data/"
    echo -e "  ${WHITE}Backups:${NC}         /opt/n8n-production/backups/"
    echo -e "  ${WHITE}Nginx:${NC}           /etc/nginx/sites-available/${DOMAIN}"
    echo -e "  ${WHITE}SSL:${NC}             /etc/letsencrypt/live/${DOMAIN}/"
    echo -e "  ${WHITE}Logs:${NC}            /var/log/n8n-install.log"
    echo ""
    
    echo -e "${CYAN}â•â•â• PRÃ“XIMOS PASOS â•â•â•${NC}"
    echo ""
    echo -e "  ${GREEN}1.${NC} Accede a ${CYAN}https://${DOMAIN}${NC}"
    echo -e "  ${GREEN}2.${NC} Inicia sesiÃ³n con las credenciales mostradas arriba"
    echo -e "  ${GREEN}3.${NC} Configura tu primer workflow"
    echo -e "  ${GREEN}4.${NC} Monitorea recursos: ${YELLOW}docker stats${NC}"
    echo ""
    
    echo -e "${YELLOW}âš ï¸  IMPORTANTE:${NC}"
    echo -e "  ${WHITE}â€¢${NC} Guarda las credenciales en un lugar seguro"
    echo -e "  ${WHITE}â€¢${NC} Los backups se ejecutan diariamente a las 2:00 AM"
    echo -e "  ${WHITE}â€¢${NC} Los certificados SSL se renuevan automÃ¡ticamente"
    echo -e "  ${WHITE}â€¢${NC} Monitorea el uso de recursos regularmente"
    echo ""
    
    # Guardar credenciales en archivo seguro
    cat > "$INSTALL_DIR/CREDENCIALES.txt" << EOF
=================================================================
CREDENCIALES N8N - $(date)
=================================================================

URL: https://${DOMAIN}
Usuario: ${N8N_ADMIN_USER}
Password: ${N8N_ADMIN_PASSWORD}

PostgreSQL Database: n8n_production
PostgreSQL User: n8n_user
PostgreSQL Password: ${POSTGRES_PASSWORD}

N8N Encryption Key: ${N8N_ENCRYPTION_KEY}
N8N Runners Token: ${N8N_RUNNERS_TOKEN}

Certbot Email: ${CERTBOT_EMAIL}

=================================================================
âš ï¸  MANTÃ‰N ESTE ARCHIVO SEGURO Y NO LO COMPARTAS
=================================================================
EOF
    
    chmod 600 "$INSTALL_DIR/CREDENCIALES.txt"
    
    echo -e "${GREEN}âœ“${NC} Credenciales guardadas en: ${CYAN}$INSTALL_DIR/CREDENCIALES.txt${NC}"
    echo ""
    
    log "InstalaciÃ³n completada exitosamente"
}

###############################################################################
# FUNCIÃ“N PRINCIPAL
###############################################################################

main() {
    print_banner
    
    log "=== INICIO DE INSTALACIÃ“N ==="
    
    # 1. Verificar root
    check_root
    
    # 2. Verificar requisitos
    check_system_requirements
    sleep 2
    
    # 3. Recopilar informaciÃ³n
    collect_user_input
    sleep 1
    
    # 4. Instalar Docker
    install_docker
    sleep 1
    
    # 5. Crear directorios
    create_directories
    sleep 1
    
    # 6. Crear archivos de configuraciÃ³n
    create_env_file
    sleep 1
    
    create_docker_compose
    sleep 1
    
    # 7. Configurar Nginx
    configure_nginx
    sleep 1
    
    # 8. Generar certificado SSL
    generate_ssl_certificate
    sleep 1
    
    # 9. Iniciar servicios Docker
    start_docker_services
    sleep 2
    
    # 10. Recargar Nginx
    reload_nginx
    sleep 1
    
    # 11. Crear scripts de mantenimiento
    create_maintenance_scripts
    sleep 1
    
    # 12. Verificar instalaciÃ³n
    verify_installation
    sleep 1
    
    # 13. Mostrar informaciÃ³n final
    show_final_info
    
    log "=== INSTALACIÃ“N FINALIZADA ==="
}

# Ejecutar instalaciÃ³n
main "$@"
